<?xml version="1.0"?>
<doc>
    <assembly>
        <name>strange</name>
    </assembly>
    <members>
        <member name="F:strange.extensions.command.api.CommandExceptionType.EXECUTE_OVERRIDE">
            Commands must always override the Execute() method.
        </member>
        <member name="F:strange.extensions.command.api.CommandExceptionType.NULL_BINDING">
            Binding wasn't found
        </member>
        <member name="F:strange.extensions.command.api.CommandExceptionType.BAD_CONSTRUCTOR">
            Something went wrong during construction, so the Command resolved to null
        </member>
        <member name="M:strange.extensions.command.api.ICommand.Execute">
            Override this! `Execute()` is where you place the logic for your Command.
        </member>
        <member name="M:strange.extensions.command.api.ICommand.Retain">
            Keeps the Command in memory. Use only in conjunction with `Release()`
        </member>
        <member name="M:strange.extensions.command.api.ICommand.Release">
            Allows a previous Retained Command to be disposed.
        </member>
        <member name="M:strange.extensions.command.api.ICommand.Fail">
            Inidcates that the Command failed
            Used in sequential command groups to terminate the sequence
        </member>
        <member name="M:strange.extensions.command.api.ICommand.Cancel">
            Inform the Command that further Execution has been terminated
        </member>
        <member name="P:strange.extensions.command.api.ICommand.IsClean">
            Flag to indicate that a pooled Command has been restored to its pristine state.
            The CommandBinder will use this to determine if re-Injection is required.
        </member>
        <member name="P:strange.extensions.command.api.ICommand.retain">
            The property set by `Retain` and `Release` to indicate whether the Command should be cleaned up on completion of the `Execute()` method. 
        </member>
        <member name="P:strange.extensions.command.api.ICommand.cancelled">
            The property set to true by a Cancel() call.
            Use cancelled internally to determine if further execution is warranted, especially in
            asynchronous calls.
        </member>
        <member name="P:strange.extensions.command.api.ICommand.data">
            A payload injected into the Command. Most commonly, this an IEvent.
        </member>
        <member name="M:strange.framework.api.IBinder.Bind``1">
            Bind a Binding Key to a class or interface generic
        </member>
        <member name="M:strange.framework.api.IBinder.Bind(System.Object)">
            Bind a Binding Key to a value
        </member>
        <member name="M:strange.framework.api.IBinder.GetBinding``1">
            Retrieve a binding based on the provided Type
        </member>
        <member name="M:strange.framework.api.IBinder.GetBinding(System.Object)">
            Retrieve a binding based on the provided object
        </member>
        <member name="M:strange.framework.api.IBinder.GetBinding``1(System.Object)">
            Retrieve a binding based on the provided Key (generic)/Name combo
        </member>
        <member name="M:strange.framework.api.IBinder.GetBinding(System.Object,System.Object)">
            Retrieve a binding based on the provided Key/Name combo
        </member>
        <member name="M:strange.framework.api.IBinder.GetRawBinding">
            Generate an unpopulated IBinding in whatever concrete form the Binder dictates
        </member>
        <member name="M:strange.framework.api.IBinder.Unbind``1">
            Remove a binding based on the provided Key (generic)
        </member>
        <member name="M:strange.framework.api.IBinder.Unbind``1(System.Object)">
            Remove a binding based on the provided Key (generic) / Name combo
        </member>
        <member name="M:strange.framework.api.IBinder.Unbind(System.Object)">
            Remove a binding based on the provided Key
        </member>
        <member name="M:strange.framework.api.IBinder.Unbind(System.Object,System.Object)">
            Remove a binding based on the provided Key / Name combo
        </member>
        <member name="M:strange.framework.api.IBinder.Unbind(strange.framework.api.IBinding)">
            Remove the provided binding from the Binder
        </member>
        <member name="M:strange.framework.api.IBinder.RemoveValue(strange.framework.api.IBinding,System.Object)">
            Remove a select value from the given binding
        </member>
        <member name="M:strange.framework.api.IBinder.RemoveKey(strange.framework.api.IBinding,System.Object)">
            Remove a select key from the given binding
        </member>
        <member name="M:strange.framework.api.IBinder.RemoveName(strange.framework.api.IBinding,System.Object)">
            Remove a select name from the given binding
        </member>
        <member name="M:strange.framework.api.IBinder.OnRemove">
            The Binder is being removed
            Override this method to clean up remaining bindings
        </member>
        <member name="M:strange.framework.api.IBinder.ResolveBinding(strange.framework.api.IBinding,System.Object)">
            <summary>
            Places individual Bindings into the bindings Dictionary as part of the resolving process
            </summary>
            Note that while some Bindings may store multiple keys, each key takes a unique position in the
            bindings Dictionary.
            
            Conflicts in the course of fluent binding are expected, but GetBinding
            will throw an error if there are any unresolved conflicts.
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.ReactTo(System.Object)">
            Trigger a key that unlocks one or more Commands
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.ReactTo(System.Object,System.Object)">
            Trigger a key that unlocks one or more Commands and provide a data injection to that Command
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.ReleaseCommand(strange.extensions.command.api.ICommand)">
            Release a previously retained Command.
            By default, a Command is garbage collected at the end of its `Execute()` method. 
            But the Command can be retained for asynchronous calls.
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.Stop(System.Object)">
            Called to halt execution of a currently running command group
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.Bind``1">
            Bind a trigger Key by generic Type
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinder.Bind(System.Object)">
            Bind a trigger Key by value
        </member>
        <member name="M:strange.framework.api.IBinding.Bind``1">
            Tie this binding to a Type key
        </member>
        <member name="M:strange.framework.api.IBinding.Bind(System.Object)">
            Tie this binding to a value key, such as a string or class instance
        </member>
        <member name="M:strange.framework.api.IBinding.To``1">
             Set the Binding's value to a Type
            
        </member>
        <member name="M:strange.framework.api.IBinding.To(System.Object)">
            Set the Binding's value to a value, such as a string or class instance
        </member>
        <member name="M:strange.framework.api.IBinding.ToName``1">
            Qualify a binding using a marker type
        </member>
        <member name="M:strange.framework.api.IBinding.ToName(System.Object)">
            Qualify a binding using a value, such as a string or class instance
        </member>
        <member name="M:strange.framework.api.IBinding.Named``1">
            Retrieve a binding if the supplied name matches, by Type
        </member>
        <member name="M:strange.framework.api.IBinding.Named(System.Object)">
            Retrieve a binding if the supplied name matches, by value
        </member>
        <member name="M:strange.framework.api.IBinding.RemoveKey(System.Object)">
            Remove a specific key from the binding.
        </member>
        <member name="M:strange.framework.api.IBinding.RemoveValue(System.Object)">
            Remove a specific value from the binding
        </member>
        <member name="M:strange.framework.api.IBinding.RemoveName(System.Object)">
            Remove a name from the binding
        </member>
        <member name="P:strange.framework.api.IBinding.key">
            Get the binding''s key
        </member>
        <member name="P:strange.framework.api.IBinding.name">
            Get the binding's name
        </member>
        <member name="P:strange.framework.api.IBinding.value">
            Get the binding's value
        </member>
        <member name="P:strange.framework.api.IBinding.keyConstraint">
            Get or set a MANY or ONE constraint on the Key
        </member>
        <member name="P:strange.framework.api.IBinding.valueConstraint">
            Get or set a MANY or ONE constraint on the Value
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinding.Once">
            Declares that the Binding is a one-off. As soon as it's satisfied, it will be unmapped.
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinding.InParallel">
            Declares that the bound commands will be run in parallel.
            Parallel is the default. There is no need to call this unless you're changing from sequence.
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinding.InSequence">
            Declares that the bound commands will be run as a sequence, rather than in parallel
        </member>
        <member name="M:strange.extensions.command.api.ICommandBinding.Pooled">
            Declares that the Commands generated by this binding will be pooled
        </member>
        <member name="P:strange.extensions.command.api.ICommandBinding.isOneOff">
            Get/set the property set to `true` by `Once()`
        </member>
        <member name="P:strange.extensions.command.api.ICommandBinding.isSequence">
            Get/set the propterty set by InSequence() and InParallel()
        </member>
        <member name="P:strange.extensions.command.api.ICommandBinding.isPooled">
            Get/set the propterty set by Pooled()
        </member>
        <member name="M:strange.extensions.pool.api.IPoolable.Restore">
            <summary>
            Clean up this instance for reuse.
            </summary>
            Restore methods should clean up the instance sufficiently to remove prior state.
        </member>
        <member name="M:strange.extensions.pool.api.IPoolable.Retain">
            <summary>
            Keep this instance from being returned to the pool 
            </summary>
        </member>
        <member name="M:strange.extensions.pool.api.IPoolable.Release">
            <summary>
            Release this instance back to the pool.
            </summary>
            Release methods should clean up the instance sufficiently to remove prior state.
        </member>
        <member name="P:strange.extensions.pool.api.IPoolable.retain">
            <summary>
            Is this instance retained?
            </summary>
            <value><c>true</c> if retained; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:strange.extensions.command.impl.Command.Restore">
            Use/override this method to clean up the Command for recycling
        </member>
        <member name="P:strange.extensions.command.impl.Command.commandBinder">
            Back reference to the CommandBinder that instantiated this Commmand
        </member>
        <member name="P:strange.extensions.command.impl.Command.injectionBinder">
            The InjectionBinder for this Context
        </member>
        <member name="F:strange.framework.impl.Binder.bindings">
            Dictionary of all bindings
            Two-layer keys. First key to individual Binding keys,
            then to Binding names. (This wouldn't be required if
            Unity supported Tuple or HashSet.)
        </member>
        <member name="M:strange.framework.impl.Binder.resolver(strange.framework.api.IBinding)">
            The default handler for resolving bindings during chained commands
        </member>
        <member name="M:strange.framework.impl.Binder.ResolveBinding(strange.framework.api.IBinding,System.Object)">
            This method places individual Bindings into the bindings Dictionary
            as part of the resolving process. Note that while some Bindings
            may store multiple keys, each key takes a unique position in the
            bindings Dictionary.
            
            Conflicts in the course of fluent binding are expected, but GetBinding
            will throw an error if there are any unresolved conflicts.
        </member>
        <member name="M:strange.framework.impl.Binder.registerNameConflict(System.Object,strange.framework.api.IBinding,strange.framework.api.IBinding)">
            Take note of bindings that are in conflict.
            This occurs routinely during fluent binding, but will spark an error if
            GetBinding is called while this Binder still has conflicts.
        </member>
        <member name="M:strange.framework.impl.Binder.isConflictCleared(System.Collections.Generic.Dictionary{strange.framework.api.IBinding,System.Object},strange.framework.api.IBinding)">
            Returns true if the provided binding and the binding in the dict are no longer conflicting
        </member>
        <member name="M:strange.framework.impl.Binder.spliceValueAt(System.Int32,System.Object[])">
            Remove the item at splicePos from the list objectValue 
        </member>
        <member name="T:strange.framework.impl.Binder.BindingResolver">
            A handler for resolving the nature of a binding during chained commands
        </member>
        <member name="M:strange.extensions.command.api.IPooledCommandBinder.GetPool``1">
            Retrieve the Pool of the specified type
        </member>
        <member name="P:strange.extensions.command.api.IPooledCommandBinder.usePooling">
            Switch to disable pooling for those that don't want to use it.
        </member>
        <member name="M:strange.extensions.dispatcher.api.ITriggerable.Trigger``1(System.Object)">
            Cause this ITriggerable to access any provided Key in its Binder by the provided generic and data.
            <returns>false if the originator should abort dispatch</returns>
        </member>
        <member name="M:strange.extensions.dispatcher.api.ITriggerable.Trigger(System.Object,System.Object)">
            Cause this ITriggerable to access any provided Key in its Binder by the provided key and data.
            <returns>false if the originator should abort dispatch</returns>
        </member>
        <member name="F:strange.extensions.command.impl.CommandBinder.activeCommands">
            Tracker for parallel commands in progress
        </member>
        <member name="F:strange.extensions.command.impl.CommandBinder.activeSequences">
            Tracker for sequences in progress
        </member>
        <member name="M:strange.extensions.command.impl.CommandException.#ctor(System.String,strange.extensions.command.api.CommandExceptionType)">
            Constructs a CommandException with a message and CommandExceptionType
        </member>
        <member name="M:strange.extensions.command.impl.EventCommandBinder.createCommand(System.Object,System.Object)">
            
        </member>
        <member name="F:strange.extensions.context.api.ContextEvent.START">
            Fires immediately on conclusion of Context bootstrapping. Map this to your first Command.
        </member>
        <member name="F:strange.extensions.context.api.ContextExceptionType.NO_CONTEXT_VIEW">
            MVCSContext requires a root ContextView
        </member>
        <member name="F:strange.extensions.context.api.ContextExceptionType.NO_MEDIATION_BINDER">
            MVCSContext requires a mediationBinder
        </member>
        <member name="F:strange.extensions.context.api.ContextKeys.CONTEXT">
            Marker for the named Injection of the Context
        </member>
        <member name="F:strange.extensions.context.api.ContextKeys.CONTEXT_VIEW">
            Marker for the named Injection of the ContextView
        </member>
        <member name="F:strange.extensions.context.api.ContextKeys.CONTEXT_DISPATCHER">
            Marker for the named Injection of the contextDispatcher
        </member>
        <member name="F:strange.extensions.context.api.ContextKeys.CROSS_CONTEXT_DISPATCHER">
            Marker for the named Injection of the crossContextDispatcher
        </member>
        <member name="M:strange.extensions.context.api.IContext.Start">
            Kicks off the internal Context binding/instantiation mechanisms 
        </member>
        <member name="M:strange.extensions.context.api.IContext.Launch">
            Fires ContextEvent.START (or the equivalent Signal) to launch the application
        </member>
        <member name="M:strange.extensions.context.api.IContext.AddContext(strange.extensions.context.api.IContext)">
            Register a new context to this one
        </member>
        <member name="M:strange.extensions.context.api.IContext.RemoveContext(strange.extensions.context.api.IContext)">
            Remove a context from this one
        </member>
        <member name="M:strange.extensions.context.api.IContext.AddView(System.Object)">
            Register a view with this context
        </member>
        <member name="M:strange.extensions.context.api.IContext.RemoveView(System.Object)">
            Remove a view from this context
        </member>
        <member name="M:strange.extensions.context.api.IContext.GetContextView">
            Get the ContextView
        </member>
        <member name="P:strange.extensions.mediation.api.IView.requiresContext">
            Indicates whether the View can work absent a context
            
            Leave this value true most of the time. If for some reason you want
            a view to exist outside a context you can set it to false. The only
            difference is whether an error gets generated.
        </member>
        <member name="P:strange.extensions.mediation.api.IView.registeredWithContext">
            Indicates whether this View  has been registered with a Context
        </member>
        <member name="P:strange.extensions.mediation.api.IView.autoRegisterWithContext">
            Exposure to code of the registerWithContext (Inspector) boolean. If false, the View won't try to register.
        </member>
        <member name="P:strange.extensions.context.api.IContextView.context">
            Get and set the Context
        </member>
        <member name="F:strange.extensions.context.impl.Context.firstContext">
            In a multi-Context app, this represents the first Context to instantiate.
        </member>
        <member name="F:strange.extensions.context.impl.Context.autoStartup">
            If false, the `Launch()` method won't fire.
        </member>
        <member name="M:strange.extensions.context.impl.Context.addCoreComponents">
            Override to add componentry. Or just extend MVCSContext.
        </member>
        <member name="M:strange.extensions.context.impl.Context.instantiateCoreComponents">
            Override to instantiate componentry. Or just extend MVCSContext.
        </member>
        <member name="M:strange.extensions.context.impl.Context.SetContextView(System.Object)">
            Set the object that represents the top of the Context hierarchy.
            In MVCSContext, this would be a GameObject.
        </member>
        <member name="M:strange.extensions.context.impl.Context.Start">
            Call this from your Root to set everything in action.
        </member>
        <member name="M:strange.extensions.context.impl.Context.Launch">
            The final method to fire after mappings.
            If autoStartup is false, you need to call this manually.
        </member>
        <member name="M:strange.extensions.context.impl.Context.mapBindings">
            Override to map project-specific bindings
        </member>
        <member name="M:strange.extensions.context.impl.Context.postBindings">
            Override to do things after binding but before app launch
        </member>
        <member name="M:strange.extensions.context.impl.Context.AddContext(strange.extensions.context.api.IContext)">
            Add another Context to this one.
        </member>
        <member name="M:strange.extensions.context.impl.Context.RemoveContext(strange.extensions.context.api.IContext)">
            Remove a context from this one.
        </member>
        <member name="M:strange.extensions.context.impl.Context.GetComponent``1">
            Retrieve a component from this Context by generic type
        </member>
        <member name="M:strange.extensions.context.impl.Context.GetComponent``1(System.Object)">
            Retrieve a component from this Context by generic type and name
        </member>
        <member name="M:strange.extensions.context.impl.Context.AddView(System.Object)">
            Register a View with this Context
        </member>
        <member name="M:strange.extensions.context.impl.Context.RemoveView(System.Object)">
            Remove a View from this Context
        </member>
        <member name="P:strange.extensions.context.impl.Context.contextView">
            The top of the View hierarchy.
            In MVCSContext, this is your top-level GameObject
        </member>
        <member name="M:strange.extensions.context.impl.ContextException.#ctor(System.String,strange.extensions.context.api.ContextExceptionType)">
            Constructs a ContextException with a message and ContextExceptionType
        </member>
        <member name="M:strange.extensions.context.impl.ContextView.OnDestroy">
            <summary>
            When a ContextView is Destroyed, automatically removes the associated Context.
            </summary>
        </member>
        <member name="M:strange.extensions.context.api.ICrossContextCapable.AssignCrossContext(strange.extensions.context.api.ICrossContextCapable)">
            Add cross-context functionality to a child context being added
        </member>
        <member name="M:strange.extensions.context.api.ICrossContextCapable.RemoveCrossContext(strange.extensions.context.api.ICrossContextCapable)">
            Clean up cross-context functionality from a child context being removed
        </member>
        <member name="M:strange.extensions.context.api.ICrossContextCapable.GetComponent``1">
            Request a component from the context (might be useful in certain cross-context situations)
            This is technically a deprecated methodology. Bind using CrossContext() instead.
        </member>
        <member name="M:strange.extensions.context.api.ICrossContextCapable.GetComponent``1(System.Object)">
            Request a component from the context (might be useful in certain cross-context situations)
            This is technically a deprecated methodology. Bind using CrossContext() instead.
        </member>
        <member name="P:strange.extensions.context.api.ICrossContextCapable.injectionBinder">
            All cross-context capable contexts must implement an injectionBinder
        </member>
        <member name="P:strange.extensions.context.api.ICrossContextCapable.crossContextDispatcher">
            Set and get the shared system bus for communicating across contexts
        </member>
        <member name="F:strange.extensions.context.impl.CrossContext._crossContextDispatcher">
            A specific instance of EventDispatcher that communicates 
            across multiple contexts. An event sent across this 
            dispatcher will be re-dispatched by the various context-wide 
            dispatchers. So a dispatch to other contexts is simply 
            
            `crossContextDispatcher.Dispatch(MY_EVENT, payload)`;
            
            Other contexts don't need to listen to the cross-context dispatcher
            as such, just map the necessary event to your local context
            dispatcher and you'll receive it.
        </member>
        <member name="P:strange.extensions.context.impl.CrossContext.injectionBinder">
            A Binder that handles dependency injection binding and instantiation
        </member>
        <member name="F:strange.extensions.context.impl.MVCSContext.viewCache">
            A list of Views Awake before the Context is fully set up.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.#ctor(UnityEngine.MonoBehaviour)">
            The recommended Constructor
            Just pass in the instance of your ContextView. Everything will begin automatically.
            Other constructors offer the option of interrupting startup at useful moments.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.addCoreComponents">
            Map the relationships between the Binders.
            Although you can override this method, it is recommended
            that you provide all your application bindings in `mapBindings()`.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.Launch">
            Fires ContextEvent.START
            Whatever Command/Sequence you want to happen first should 
            be mapped to this event.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.GetComponent``1">
            Gets an instance of the provided generic type.
            Always bear in mind that doing this risks adding
            dependencies that must be cleaned up when Contexts
            are removed.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.GetComponent``1(System.Object)">
            Gets an instance of the provided generic type and name from the InjectionBinder
            Always bear in mind that doing this risks adding
            dependencies that must be cleaned up when Contexts
            are removed.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.cacheView(UnityEngine.MonoBehaviour)">
            Caches early-riser Views.
            
            If a View is on stage at startup, it's possible for that
            View to be Awake before this Context has finished initing.
            `cacheView()` maintains a list of such 'early-risers'
            until the Context is ready to mediate them.
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.mediateViewCache">
            Provide mediation for early-riser Views
        </member>
        <member name="M:strange.extensions.context.impl.MVCSContext.OnRemove">
            Clean up. Called by a ContextView in its OnDestroy method
        </member>
        <member name="P:strange.extensions.context.impl.MVCSContext.commandBinder">
            A Binder that maps Events to Commands
        </member>
        <member name="P:strange.extensions.context.impl.MVCSContext.dispatcher">
            A Binder that serves as the Event bus for the Context
        </member>
        <member name="P:strange.extensions.context.impl.MVCSContext.mediationBinder">
            A Binder that maps Views to Mediators
        </member>
        <member name="P:strange.extensions.context.impl.MVCSContext.sequencer">
            A Binder that maps Events to Sequences
        </member>
        <member name="F:strange.extensions.dispatcher.api.DispatcherExceptionType.NULL_FACTORY">
            Injector Factory not found
        </member>
        <member name="F:strange.extensions.dispatcher.api.DispatcherExceptionType.ILLEGAL_CALLBACK_HANDLER">
            Callback must be a Delegate with zero or one argument
        </member>
        <member name="M:strange.extensions.dispatcher.api.IDispatcher.Dispatch(System.Object)">
            Send a notification of type eventType. No data.
            In MVCSContext this dispatches an IEvent.
        </member>
        <member name="M:strange.extensions.dispatcher.api.IDispatcher.Dispatch(System.Object,System.Object)">
            Send a notification of type eventType and the provided data payload.
            In MVCSContext this dispatches an IEvent.
        </member>
        <member name="M:strange.extensions.dispatcher.api.ITriggerProvider.AddTriggerable(strange.extensions.dispatcher.api.ITriggerable)">
            Register a Triggerable client with this provider.
        </member>
        <member name="M:strange.extensions.dispatcher.api.ITriggerProvider.RemoveTriggerable(strange.extensions.dispatcher.api.ITriggerable)">
            Remove a previously registered Triggerable client from this provider.
        </member>
        <member name="P:strange.extensions.dispatcher.api.ITriggerProvider.Triggerables">
            Count of the current number of trigger clients.
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventCallbackType.NO_ARGUMENTS">
            Indicates an EventCallback with no arguments
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventCallbackType.ONE_ARGUMENT">
            Indicates an EventCallback with one argument
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventCallbackType.NOT_FOUND">
            Indicates no matching EventCallback could be found
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventDispatcherExceptionType.EVENT_KEY_NULL">
            Indicates that an event was fired with null as the key.
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventDispatcherExceptionType.EVENT_TYPE_MISMATCH">
            Indicates that the type of Event in the call and the type of Event in the payload don't match.
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.api.EventDispatcherExceptionType.TARGET_INVOCATION">
            When attempting to fire a callback, the callback was discovered to be casting illegally.
        </member>
        <member name="P:strange.extensions.dispatcher.eventdispatcher.api.IEvent.type">
            The Event key
        </member>
        <member name="P:strange.extensions.dispatcher.eventdispatcher.api.IEvent.target">
            The IEventDispatcher that sent the event
        </member>
        <member name="P:strange.extensions.dispatcher.eventdispatcher.api.IEvent.data">
            An arbitrary data payload
        </member>
        <member name="T:strange.extensions.dispatcher.eventdispatcher.api.EventCallback">
            Delegate for adding a listener with a single argument
        </member>
        <member name="T:strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback">
            Delegate for adding a listener with a no arguments
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventBinding.TypeForCallback(strange.extensions.dispatcher.eventdispatcher.api.EventCallback)">
            Retrieve the type of the provided callback
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventBinding.TypeForCallback(strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback)">
            Retrieve the type of the provided callback
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.AddListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EventCallback)">
            Add an observer with exactly one argument to this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.AddListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback)">
            Add an observer with exactly no arguments to this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.RemoveListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EventCallback)">
            Remove a previously registered observer with exactly one argument from this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.RemoveListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback)">
            Remove a previously registered observer with exactly no arguments from this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.HasListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EventCallback)">
            Returns true if the provided observer is already registered
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.HasListener(System.Object,strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback)">
            Returns true if the provided observer is already registered
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.UpdateListener(System.Boolean,System.Object,strange.extensions.dispatcher.eventdispatcher.api.EventCallback)">
            By passing true, an observer with exactly one argument will be added to this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.UpdateListener(System.Boolean,System.Object,strange.extensions.dispatcher.eventdispatcher.api.EmptyCallback)">
            By passing true, an observer with exactly no arguments will be added to this Dispatcher
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher.ReleaseEvent(strange.extensions.dispatcher.eventdispatcher.api.IEvent)">
            Allow a previously retained event to be returned to its pool
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.impl.EventDispatcher.triggerClients">
            The list of clients that will be triggered as a consequence of an Event firing.
        </member>
        <member name="F:strange.extensions.dispatcher.eventdispatcher.impl.EventDispatcher.eventPool">
            The eventPool is shared across all EventDispatchers for efficiency
        </member>
        <!-- Badly formed XML comment ignored for member "M:strange.framework.api.IInstanceProvider.GetInstance``1" -->
        <member name="M:strange.framework.api.IInstanceProvider.GetInstance(System.Type)">
            Retrieve an Instance based on the key.
            ex. `injectionBinder.Get(typeof(ISomeInterface));`
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.impl.EventDispatcherException.#ctor(System.String,strange.extensions.dispatcher.eventdispatcher.api.EventDispatcherExceptionType)">
            Constructs an EventDispatcherException with a message and EventDispatcherExceptionType
        </member>
        <member name="M:strange.extensions.dispatcher.eventdispatcher.impl.TmEvent.#ctor(System.Object,strange.extensions.dispatcher.eventdispatcher.api.IEventDispatcher,System.Object)">
            Construct a TmEvent
        </member>
        <member name="M:strange.extensions.dispatcher.impl.DispatcherException.#ctor(System.String,strange.extensions.dispatcher.api.DispatcherExceptionType)">
            Constructs a DispatcherException with a message and DispatcherExceptionType
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinder.GetInstance(System.Type,System.Object)">
            Retrieve an Instance based on a key/name combo.
            ex. `injectionBinder.Get(typeof(ISomeInterface), SomeEnum.MY_ENUM);`
        </member>
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.injector.api.IInjectionBinder.GetInstance``1(System.Object)" -->
        <member name="M:strange.extensions.injector.api.IInjectionBinder.Reflect(System.Collections.Generic.List{System.Type})">
            Reflect all the types in the list
            Return the number of types in the list, which should be equal to the list length
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinder.ReflectAll">
            Reflect all the types currently registered with InjectionBinder
            Return the number of types reflected, which should be equal to the number
            of concrete classes you've mapped.
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinder.ResolveBinding(strange.framework.api.IBinding,System.Object)">
            <summary>
            Places individual Bindings into the bindings Dictionary as part of the resolving process
            </summary>
            Note that while some Bindings may store multiple keys, each key takes a unique position in the
            bindings Dictionary.
            
            Conflicts in the course of fluent binding are expected, but GetBinding
            will throw an error if there are any unresolved conflicts.
        </member>
        <member name="P:strange.extensions.injector.api.IInjectionBinder.injector">
            Get or set an Injector to use. By default, Injector instantiates it's own, but that can be overridden.
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinding.ToSingleton">
            Map the Binding to a Singleton so that every `GetInstance()` on the Binder Key returns the same imstance.
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinding.ToValue(System.Object)">
            Map the Binding to a stated instance so that every `GetInstance()` on the Binder Key returns the provided imstance. Sets type to Value
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinding.SetValue(System.Object)">
            Map the Binding to a stated instance so that every `GetInstance()` on the Binder Key returns the provided imstance. Does not set type.
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinding.CrossContext">
            Map the binding and give access to all contexts in hierarchy
        </member>
        <member name="M:strange.extensions.injector.api.IInjectionBinding.ToInject(System.Boolean)">
            Boolean setter to optionally override injection. If false, the instance will not be injected after instantiation.
        </member>
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.injector.api.IInjectionBinding.Bind``1" -->
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.injector.api.IInjectionBinding.Bind(System.Object)" -->
        <member name="P:strange.extensions.injector.api.IInjectionBinding.toInject">
            Get the parameter that specifies whether this Binding allows an instance to be injected
        </member>
        <member name="P:strange.extensions.injector.api.IInjectionBinding.type">
            Get and set the InjectionBindingType
            @see InjectionBindingType
        </member>
        <member name="M:strange.extensions.injector.api.IInjector.Instantiate(strange.extensions.injector.api.IInjectionBinding)">
            Request an instantiation based on the given binding.
            This request is made to the Injector, but it's really the InjectorFactory that does the instantiation.
        </member>
        <member name="M:strange.extensions.injector.api.IInjector.Inject(System.Object)">
            Request that the provided target be injected.
        </member>
        <member name="M:strange.extensions.injector.api.IInjector.Inject(System.Object,System.Boolean)">
            Request that the provided target be injected.
        </member>
        <member name="M:strange.extensions.injector.api.IInjector.Uninject(System.Object)">
            Clear the injections from the provided instance.
            Note that Uninject can only clean public properties...therefore only
            setters will be uninjected...not injections provided via constructor injection
        </member>
        <member name="P:strange.extensions.injector.api.IInjector.factory">
            Get/set an InjectorFactory.
        </member>
        <member name="P:strange.extensions.injector.api.IInjector.binder">
            Get/set an InjectionBinder.
        </member>
        <member name="P:strange.extensions.injector.api.IInjector.reflector">
            Get/set a ReflectionBinder.
        </member>
        <member name="M:strange.extensions.injector.api.IInjectorFactory.Get(strange.extensions.injector.api.IInjectionBinding)">
            Request instantiation based on the provided binding
        </member>
        <member name="M:strange.extensions.injector.api.IInjectorFactory.Get(strange.extensions.injector.api.IInjectionBinding,System.Object[])">
            Request instantiation based on the provided binding and an array of Constructor arguments
        </member>
        <member name="F:strange.extensions.injector.api.InjectionBindingType.DEFAULT">
            The binding provides a new instance every time
        </member>
        <member name="F:strange.extensions.injector.api.InjectionBindingType.SINGLETON">
            The binding always provides the same instance
        </member>
        <member name="F:strange.extensions.injector.api.InjectionBindingType.VALUE">
            The binding always provides the same instance based on a provided value
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.CIRCULAR_DEPENDENCY">
            A circular dependency was found.
            This Exception was raised to prevent a stack overflow.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.ILLEGAL_BINDING_VALUE">
            The value of a binding does not extend or implement the binding type.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NO_BINDER">
            No InjectionBinder found.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NO_REFLECTOR">
            No ReflectionBinder found.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NO_FACTORY">
            No InjectorFactory found.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NOT_INSTANTIABLE">
            The provided binding is not an instantiable class.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_BINDING">
            The requested Binding was null or couldn't be found.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_CONSTRUCTOR">
            During an attempt to construct, no constructor was found.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_INJECTION_POINT">
            During setter injection the requested setter resolved to null.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_REFLECTION">
            No reflection was provided for the requested class.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_TARGET">
            The instance being injected into resolved to null.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.NULL_VALUE_INJECTION">
            The value being injected into the target resolved to null.
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.SETTER_NAME_MISMATCH">
            The list of setters and setter names must have exactly the same number of entries.
            Two lists are required because Unity does not at present support Tuple.
            Seeing this error likely indicates a problem with the Reflector (it's not you, it's me).
        </member>
        <member name="F:strange.extensions.injector.api.InjectionExceptionType.MISSING_CROSS_CONTEXT_INJECTOR">
            The requested cross-context injector returned null
        </member>
        <member name="M:strange.extensions.injector.impl.InjectionException.#ctor(System.String,strange.extensions.injector.api.InjectionExceptionType)">
            Constructs an InjectionException with a message and InjectionExceptionType
        </member>
        <member name="M:strange.extensions.injector.impl.InjectorFactory.singletonOf(strange.extensions.injector.api.IInjectionBinding,System.Object[])">
            Generate a Singleton instance
        </member>
        <member name="M:strange.extensions.injector.impl.InjectorFactory.valueOf(strange.extensions.injector.api.IInjectionBinding)">
            The binding already has a value. Simply return it.
        </member>
        <member name="M:strange.extensions.injector.impl.InjectorFactory.instanceOf(strange.extensions.injector.api.IInjectionBinding,System.Object[])">
            Generate a new instance
        </member>
        <member name="M:strange.extensions.injector.impl.InjectorFactory.createFromValue(System.Object,System.Object[])">
            Call the Activator to attempt instantiation the given object
        </member>
        <member name="M:strange.extensions.mediation.api.IMediationBinder.Trigger(strange.extensions.mediation.api.MediationEvent,strange.extensions.mediation.api.IView)">
            An event that just happened, and the View it happened to.
            If the event was Awake, it will trigger creation of a mapped Mediator.
        </member>
        <member name="M:strange.extensions.mediation.api.IMediationBinder.Bind``1">
            Recast binding as IMediationBinding.
        </member>
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.mediation.api.IMediationBinder.BindView``1" -->
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.mediation.api.IMediationBinding.ToMediator``1" -->
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.mediation.api.IMediationBinding.ToAbstraction``1" -->
        <!-- Badly formed XML comment ignored for member "P:strange.extensions.mediation.api.IMediationBinding.abstraction" -->
        <member name="M:strange.extensions.mediation.api.IMediator.PreRegister">
            This method fires immediately after instantiation, but before injection.
            Override to handle anything that needs to happen prior to injection.
        </member>
        <member name="M:strange.extensions.mediation.api.IMediator.OnRegister">
            This method fires immediately after injection.
            Override to perform the actions you might normally perform in a constructor.
        </member>
        <member name="M:strange.extensions.mediation.api.IMediator.OnRemove">
            This method fires just before a GameObject will be destroyed.
            Override to clean up any listeners, or anything else that might keep the View/Mediator pair from being garbage collected.
        </member>
        <member name="P:strange.extensions.mediation.api.IMediator.contextView">
            Get/set the GameObject that represents the top-most item in this Context
        </member>
        <member name="F:strange.extensions.mediation.api.MediationEvent.AWAKE">
            The View is Awake
        </member>
        <member name="F:strange.extensions.mediation.api.MediationEvent.DESTROYED">
            The View is about to be Destroyed
        </member>
        <member name="F:strange.extensions.mediation.api.MediationEvent.ENABLED">
            The View is being Enabled
        </member>
        <member name="F:strange.extensions.mediation.api.MediationEvent.DISABLED">
            The View is being Disabled
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.NO_CONTEXT">
            Exception raised when a View can't locate a Context.
            Views contact the Context by "bubbling" their existence up 
            the display chain (recursively using transform.parent).
            If a View reaches the top of that chain without locating
            a Context, it will raise this Exception to warn you.
            
            Note: to avoid infinite looping, there is a bubbling limit of 100
            layers. If your View needs to be more than 100 transforms deep, 
            that might signal a design problem.
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.MEDIATOR_VIEW_STACK_OVERFLOW">
            Exception raised when a View is mapped to itself.
            If a View is accidentally mapped to itself, the result will be an
            infinite loop of Mediation creation.
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.NULL_MEDIATOR">
            Exception raised when AddComponent results in a null Mediator.
            This probably means that the mapped "mediator" wasn't a MonoBehaviour.
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.IMPLICIT_BINDING_MEDIATOR_TYPE_IS_NULL">
            The mediator type is null on the attribute tag
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.IMPLICIT_BINDING_VIEW_TYPE_IS_NULL">
            The view type is null on the attribute tag
        </member>
        <member name="F:strange.extensions.mediation.api.MediationExceptionType.VIEW_NOT_ASSIGNABLE">
            View bound to abstraction that View doesn't actually extend/implement
        </member>
        <member name="M:strange.extensions.mediation.impl.Mediator.PreRegister">
            Fires directly after creation and before injection
        </member>
        <member name="M:strange.extensions.mediation.impl.Mediator.OnRegister">
             Fires after all injections satisifed.
            
             Override and place your initialization code here.
        </member>
        <member name="M:strange.extensions.mediation.impl.Mediator.OnRemove">
             Fires on removal of view.
            
             Override and place your cleanup code here
        </member>
        <member name="F:strange.extensions.mediation.impl.View._requiresContext">
            Leave this value true most of the time. If for some reason you want
            a view to exist outside a context you can set it to false. The only
            difference is whether an error gets generated.
        </member>
        <member name="F:strange.extensions.mediation.impl.View.registerWithContext">
            A flag for allowing the View to register with the Context
            In general you can ignore this. But some developers have asked for a way of disabling
             View registration with a checkbox from Unity, so here it is.
            If you want to expose this capability either
            (1) uncomment the commented-out line immediately below, or
            (2) subclass View and override the autoRegisterWithContext method using your own custom (public) field.
        </member>
        <member name="M:strange.extensions.mediation.impl.View.Awake">
            A MonoBehaviour Awake handler.
            The View will attempt to connect to the Context at this moment.
        </member>
        <member name="M:strange.extensions.mediation.impl.View.Start">
            A MonoBehaviour Start handler
            If the View is not yet registered with the Context, it will 
            attempt to connect again at this moment.
        </member>
        <member name="M:strange.extensions.mediation.impl.View.OnDestroy">
            A MonoBehaviour OnDestroy handler
            The View will inform the Context that it is about to be
            destroyed.
        </member>
        <member name="M:strange.extensions.mediation.impl.View.bubbleToContext(UnityEngine.MonoBehaviour,System.Boolean,System.Boolean)">
            Recurses through Transform.parent to find the GameObject to which ContextView is attached
            Has a loop limit of 100 levels.
            By default, raises an Exception if no Context is found.
        </member>
        <member name="M:strange.extensions.mediation.impl.MediationBinder.injectViewAndChildren(strange.extensions.mediation.api.IView)">
            Initialize all IViews within this view
        </member>
        <member name="M:strange.extensions.mediation.impl.MediationBinder.mapView(strange.extensions.mediation.api.IView,strange.extensions.mediation.api.IMediationBinding)">
            Creates and registers one or more Mediators for a specific View instance.
            Takes a specific View instance and a binding and, if a binding is found for that type, creates and registers a Mediator.
        </member>
        <member name="M:strange.extensions.mediation.impl.MediationBinder.unmapView(strange.extensions.mediation.api.IView,strange.extensions.mediation.api.IMediationBinding)">
            Removes a mediator when its view is destroyed
        </member>
        <member name="M:strange.extensions.mediation.impl.MediationException.#ctor(System.String,strange.extensions.mediation.api.MediationExceptionType)">
            Constructs a MediationException with a message and MediationExceptionType
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.Constructor">
            Get/set the preferred constructor
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.ConstructorParameters">
            Get/set the preferred constructor's list of parameters
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.PostConstructors">
            Get/set any PostConstructors. This includes inherited PostConstructors.
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.Setters">
            Get/set the list of setter injections. This includes inherited setters.
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.PreGenerated">
            For testing. Allows a unit test to assert whether the binding was
            generated on the current call, or on a prior one.
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.constructor">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.constructorParameters">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.postConstructors">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.setters">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.setterNames">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="P:strange.extensions.reflector.api.IReflectedClass.preGenerated">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="M:strange.extensions.reflector.api.IReflectionBinder.Get(System.Type)">
            Get a binding based on the provided Type
        </member>
        <member name="M:strange.extensions.reflector.api.IReflectionBinder.Get``1">
            Get a binding based on the provided Type generic.
        </member>
        <member name="F:strange.extensions.reflector.api.ReflectionExceptionType.CANNOT_REFLECT_INTERFACE">
            The reflector requires a constructor, which Interfaces don't provide.
        </member>
        <member name="F:strange.extensions.reflector.api.ReflectionExceptionType.CANNOT_INJECT_INTO_NONPUBLIC_SETTER">
            The reflector is not allowed to inject into private/protected setters.
        </member>
        <member name="P:strange.extensions.reflector.impl.ReflectedClass.constructor">
            [Obsolete"Strange migration to conform to C# guidelines. Removing camelCased publics"]
        </member>
        <member name="M:strange.extensions.reflector.impl.ReflectionBinder.Add(System.Object,System.Object[])">
            Add an item to a list
        </member>
        <member name="M:strange.extensions.reflector.impl.ReflectionBinder.AddKV(System.Collections.Generic.KeyValuePair{System.Type,System.Reflection.PropertyInfo},System.Collections.Generic.KeyValuePair{System.Type,System.Reflection.PropertyInfo}[])">
            Add an item to a list
        </member>
        <member name="M:strange.extensions.reflector.impl.ReflectionException.#ctor(System.String,strange.extensions.reflector.api.ReflectionExceptionType)">
            Constructs a ReflectionException with a message and ReflectionExceptionType
        </member>
        <member name="M:strange.extensions.sequencer.api.ISequenceBinding.Once">
            Declares that the Binding is a one-off. As soon as it's satisfied, it will be unmapped.
        </member>
        <member name="P:strange.extensions.sequencer.api.ISequenceBinding.isOneOff">
            Get/set the property set to `true` by `Once()`
        </member>
        <member name="M:strange.extensions.sequencer.api.ISequencer.ReleaseCommand(strange.extensions.sequencer.api.ISequenceCommand)">
            Release a previously retained SequenceCommand.
            By default, a Command is garbage collected at the end of its `Execute()` method. 
            But the Command can be retained for asynchronous calls.
        </member>
        <member name="F:strange.extensions.sequencer.api.SequencerExceptionType.EXECUTE_OVERRIDE">
            SequenceCommands must always override the Execute() method.
        </member>
        <member name="F:strange.extensions.sequencer.api.SequencerExceptionType.COMMAND_USED_IN_SEQUENCE">
            This exception is raised if the mapped Command doesn't implement ISequenceCommand. 
        </member>
        <member name="P:strange.extensions.sequencer.impl.EventSequenceCommand.dispatcher">
            The context-wide Event bus
        </member>
        <member name="P:strange.extensions.sequencer.impl.EventSequenceCommand.evt">
            The injected IEvent
        </member>
        <member name="M:strange.extensions.sequencer.impl.Sequencer.createCommand(System.Object,System.Object)">
            Instantiate and Inject the ISequenceCommand.
        </member>
        <member name="M:strange.extensions.sequencer.impl.EventSequencer.createCommand(System.Object,System.Object)">
            Instantiate and Inject the command, incling an IEvent to data.
        </member>
        <member name="M:strange.extensions.sequencer.impl.SequencerException.#ctor(System.String,strange.extensions.sequencer.api.SequencerExceptionType)">
            Constructs a SequencerException with a message and SequencerExceptionType
        </member>
        <member name="F:strange.framework.api.BinderExceptionType.CONFLICT_IN_BINDER">
            The binder is being used while one or more Bindings are in conflict
        </member>
        <member name="F:strange.framework.api.BindingConst.NULLOID">
            Null is an acceptable binding, but dictionaries choke on it, so we map null to this instead.
        </member>
        <member name="F:strange.framework.api.BindingConstraintType.ONE">
            Constrains a SemiBinding to carry no more than one item in its Value
        </member>
        <member name="F:strange.framework.api.BindingConstraintType.MANY">
            Constrains a SemiBinding to carry a list of items in its Value
        </member>
        <member name="F:strange.framework.api.BindingConstraintType.POOL">
            Instructs the Binding to apply a Pool instead of a SemiBinding
        </member>
        <member name="M:strange.framework.api.IManagedList.Add(System.Object)">
            Add a value to this List. 
        </member>
        <member name="M:strange.framework.api.IManagedList.Add(System.Object[])">
            Add a set of values to this List. 
        </member>
        <member name="M:strange.framework.api.IManagedList.Remove(System.Object)">
            Remove a value from this List. 
        </member>
        <member name="M:strange.framework.api.IManagedList.Remove(System.Object[])">
            Remove a set of values from this List. 
        </member>
        <member name="P:strange.framework.api.IManagedList.value">
            Retrieve the value of this List.
            If the constraint is MANY, the value will be an Array.
            If the constraint is POOL, this becomes a synonym for GetInstance().
        </member>
        <member name="P:strange.framework.api.ISemiBinding.constraint">
            Set or get the constraint. 
        </member>
        <member name="P:strange.framework.api.ISemiBinding.uniqueValues">
            A secondary constraint that ensures that this SemiBinding will never contain multiple values equivalent to each other. 
        </member>
        <member name="M:strange.framework.impl.BinderException.#ctor(System.String,strange.framework.api.BinderExceptionType)">
            Constructs a BinderException with a message and BinderExceptionType
        </member>
        <member name="M:strange.framework.impl.SemiBinding.spliceValueAt(System.Int32)">
            Remove the value at index splicePos
        </member>
        <member name="M:strange.extensions.signal.api.IBaseSignal.Dispatch(System.Object[])">
            Instruct a Signal to call on all its registered listeners
        </member>
        <member name="M:strange.extensions.signal.api.IBaseSignal.AddListener(System.Action{strange.extensions.signal.api.IBaseSignal,System.Object[]})">
            Attach a callback to this Signal
            The callback parameters must match the Types and order which were
            originally assigned to the Signal on its creation
        </member>
        <member name="M:strange.extensions.signal.api.IBaseSignal.AddOnce(System.Action{strange.extensions.signal.api.IBaseSignal,System.Object[]})">
            Attach a callback to this Signal for the duration of exactly one Dispatch
            The callback parameters must match the Types and order which were
            originally assigned to the Signal on its creation, and the callback
            will be removed immediately after the Signal dispatches
        </member>
        <member name="M:strange.extensions.signal.api.IBaseSignal.RemoveListener(System.Action{strange.extensions.signal.api.IBaseSignal,System.Object[]})">
            Remove a callback from this Signal
        </member>
        <!-- Badly formed XML comment ignored for member "M:strange.extensions.signal.api.IBaseSignal.GetTypes" -->
        <member name="E:strange.extensions.signal.impl.BaseSignal.BaseListener">
            The delegate for repeating listeners
        </member>
        <member name="E:strange.extensions.signal.impl.BaseSignal.OnceBaseListener">
            The delegate for one-off listeners
        </member>
        <member name="T:strange.extensions.signal.impl.Signal">
            Base concrete form for a Signal with no parameters
        </member>
        <member name="T:strange.extensions.signal.impl.Signal`1">
            Base concrete form for a Signal with one parameter
        </member>
        <member name="T:strange.extensions.signal.impl.Signal`2">
            Base concrete form for a Signal with two parameters
        </member>
        <member name="T:strange.extensions.signal.impl.Signal`3">
            Base concrete form for a Signal with three parameters
        </member>
        <member name="T:strange.extensions.signal.impl.Signal`4">
            Base concrete form for a Signal with four parameters
        </member>
        <member name="M:strange.extensions.signal.impl.SignalException.#ctor(System.String,strange.extensions.signal.api.SignalExceptionType)">
            Constructs a SignalException with a message and SignalExceptionType
        </member>
        <member name="M:strange.extensions.command.impl.SignalCommandBinder.createCommandForSignal(System.Type,System.Object,System.Collections.Generic.List{System.Type})">
            Create a Command and bind its injectable parameters to the Signal types
        </member>
        <member name="M:strange.extensions.command.impl.SignalCommandBinder.Unbind``1">
            <summary>Unbind by Signal Type</summary>
            <exception cref="T:strange.extensions.injector.impl.InjectionException">If there is no binding for this type.</exception>
        </member>
        <member name="M:strange.extensions.command.impl.SignalCommandBinder.Unbind(System.Object,System.Object)">
            <summary>Unbind by Signal Instance</summary>
            <param name="key">Instance of IBaseSignal</param>
        </member>
        <member name="F:strange.extensions.signal.api.SignalExceptionType.COMMAND_VALUE_CONFLICT">
            Attempting to bind more than one value of the same type to a command
        </member>
        <member name="F:strange.extensions.signal.api.SignalExceptionType.COMMAND_VALUE_NOT_FOUND">
            A Signal mapped to a Command found no matching injectable Type to bind a parameter to.
        </member>
        <member name="F:strange.extensions.signal.api.SignalExceptionType.COMMAND_NULL_INJECTION">
            SignalCommandBinder attempted to bind a null value from a signal to a Command
        </member>
        <member name="F:strange.extensions.context.impl.CrossContextBridge.eventsInProgress">
            Prevents the currently dispatching Event from cycling back on itself
        </member>
        <member name="M:strange.extensions.pool.api.IPool.GetInstance">
            <summary>
            Gets an instance from the pool if one is available.
            </summary>
            <returns>The instance.</returns>
        </member>
        <member name="M:strange.extensions.pool.api.IPool.ReturnInstance(System.Object)">
            <summary>
            Returns an instance to the pool.
            </summary>
            If the instance being released implements IPoolable, the Release() method will be called.
            <param name="value">The instance to be return to the pool.</param>
        </member>
        <member name="M:strange.extensions.pool.api.IPool.Clean">
            <summary>
            Remove all instance references from the Pool.
            </summary>
        </member>
        <member name="P:strange.extensions.pool.api.IPool.instanceProvider">
            A class that provides instances to the pool when it needs them.
            This can be the InjectionBinder, or any class you write that satisfies the IInstanceProvider
            interface.
        </member>
        <member name="P:strange.extensions.pool.api.IPool.poolType">
            The object Type of the first object added to the pool.
            Pool objects must be of the same concrete type. This property enforces that requirement. 
        </member>
        <member name="P:strange.extensions.pool.api.IPool.available">
            <summary>
            Returns the count of non-committed instances
            </summary>
        </member>
        <member name="P:strange.extensions.pool.api.IPool.size">
            <summary>
            Gets or sets the size of the pool.
            </summary>
            <value>The pool size. '0' is a special value indicating infinite size. Infinite pools expand as necessary to accomodate requirement.</value>
        </member>
        <member name="P:strange.extensions.pool.api.IPool.instanceCount">
            <summary>
            Returns the total number of instances currently managed by this pool.
            </summary>
        </member>
        <member name="P:strange.extensions.pool.api.IPool.overflowBehavior">
            <summary>
            Gets or sets the overflow behavior of this pool.
            </summary>
            <value>A PoolOverflowBehavior value.</value>
        </member>
        <member name="P:strange.extensions.pool.api.IPool.inflationType">
            <summary>
            Gets or sets the type of inflation for infinite-sized pools.
            </summary>
            By default, a pool doubles its InstanceCount.
            <value>A PoolInflationType value.</value>
        </member>
        <member name="F:strange.extensions.pool.impl.Pool.instancesAvailable">
            Stack of instances still in the Pool.
        </member>
        <member name="F:strange.extensions.pool.impl.Pool.instancesInUse">
            A HashSet of the objects checked out of the Pool.
        </member>
        <member name="M:strange.extensions.pool.impl.Pool.removeInstance(System.Object)">
            <summary>
            Permanently removes an instance from the Pool
            </summary>
            In the event that the removed Instance is in use, it is removed from instancesInUse.
            Otherwise, it is presumed inactive, and the next available object is popped from
            instancesAvailable.
            <param name="value">An instance to remove permanently from the Pool.</param>
        </member>
        <member name="P:strange.extensions.pool.impl.Pool.poolType">
            The object Type of the first object added to the pool.
            Pool objects must be of the same concrete type. This property enforces that requirement. 
        </member>
        <member name="M:strange.extensions.pool.impl.PoolException.#ctor(System.String,strange.extensions.pool.api.PoolExceptionType)">
            Constructs a PoolException with a message and PoolExceptionType
        </member>
        <member name="F:strange.extensions.pool.api.PoolExceptionType.OVERFLOW">
            POOL HAS OVERFLOWED ITS LIMIT
        </member>
        <member name="F:strange.extensions.pool.api.PoolExceptionType.TYPE_MISMATCH">
            ATTEMPT TO ADD AN INSTANCE OF DIFFERENT TYPE TO A POOL
        </member>
        <member name="F:strange.extensions.pool.api.PoolExceptionType.NO_INSTANCE_PROVIDER">
            A POOL HAS NO INSTANCE PROVIDER
        </member>
        <member name="F:strange.extensions.pool.api.PoolInflationType.INCREMENT">
            When a dynamic pool inflates, add one to the pool.
        </member>
        <member name="F:strange.extensions.pool.api.PoolInflationType.DOUBLE">
            When a dynamic pool inflates, double the size of the pool
        </member>
        <member name="F:strange.extensions.pool.api.PoolOverflowBehavior.EXCEPTION">
            Requesting more than the fixed size will throw an exception.
        </member>
        <member name="F:strange.extensions.pool.api.PoolOverflowBehavior.WARNING">
            Requesting more than the fixed size will throw a warning.
        </member>
        <member name="F:strange.extensions.pool.api.PoolOverflowBehavior.IGNORE">
            Requesting more than the fixed size will return null and not throw an error.
        </member>
        <member name="F:strange.extensions.command.api.CommandKeys.COMMAND_POOL">
            Temporary marker for any pool instantiated by the CommandBinder
        </member>
        <member name="F:strange.extensions.context.api.ContextStartupFlags.AUTOMATIC">
            Context will map bindings and launch automatically (default).
        </member>
        <member name="F:strange.extensions.context.api.ContextStartupFlags.MANUAL_MAPPING">
            Context startup will halt after Core bindings are mapped, but before instantiation or any custom bindings.
            If this flag is invoked, the developer must call context.Start()
        </member>
        <member name="F:strange.extensions.context.api.ContextStartupFlags.MANUAL_LAUNCH">
            Context startup will halt after all bindings are mapped, but before firing ContextEvent.START (or the analogous Signal).
            If this flag is invoked, the developer must call context.Launch()
        </member>
        <member name="T:Implements">
            <summary>
            Declares a Class to be implicitly bound.
            No arguments binds a concrete class to itself
            Passing an Interface binds to that interface
            Implements overrides ImplementedBy
            </summary>
        </member>
        <member name="M:Implements.#ctor">
            <summary>
            Concretely bind to own type
            </summary>
        </member>
        <member name="M:Implements.#ctor(strange.extensions.injector.api.InjectionBindingScope)">
            <summary>
            Concretely bind to own type and specify scope
            </summary>
            <param name="scope"></param>
        </member>
        <member name="M:Implements.#ctor(System.Type,strange.extensions.injector.api.InjectionBindingScope)">
            <summary>
            Bind to an interface, specify the scope if necessary
            </summary>
            <param name="t">Interface to bind to</param>
            <param name="scope">Single Context(default) or Cross Context.</param>
        </member>
        <member name="M:Implements.#ctor(strange.extensions.injector.api.InjectionBindingScope,System.Object)">
            <summary>
            Bind concretely, specifying a scope and object name
            </summary>
            <param name="scope"></param>
            <param name="name"></param>
        </member>
        <member name="M:Implements.#ctor(System.Type,strange.extensions.injector.api.InjectionBindingScope,System.Object)">
            <summary>
            Bind to an interface, specifying a scope and object name
            </summary>
            <param name="t">Interface to bind to</param>
            <param name="scope">Single Context or Cross Context</param>
            <param name="name">Name to bind to</param>
        </member>
        <member name="T:ImplementedBy">
            <summary>
            Declares an interface to have an implicit implementor
            An Implements tag for the given interface overrides this tag.
            </summary>
        </member>
        <member name="M:ImplementedBy.#ctor(System.Type,strange.extensions.injector.api.InjectionBindingScope)">
            <summary>
            Bind this interface to a default type t
            </summary>
            <param name="t">Default Type</param>
            <param name="scope">Single Context(default) or Cross Context</param>
        </member>
        <member name="T:MediatedBy">
            <summary>
            Declares a View class implicity mediated by one or more named Mediators
            </summary>
        </member>
        <member name="M:MediatedBy.#ctor(System.Type)">
            <summary>
            Bind this view to a Mediator
            </summary>
            <param name="t">Mediator Type</param>
        </member>
        <member name="T:Mediates">
            <summary>
            Declare a Mediator class implicitly bound to a provided View
            </summary>
        </member>
        <member name="M:Mediates.#ctor(System.Type)">
            <summary>
            Bind this Mediator to a view
            </summary>
            <param name="t">View Type</param>
        </member>
        <member name="M:strange.extensions.implicitBind.api.IImplicitBinder.ScanForAnnotatedClasses(System.String[])">
            <summary>
            Search through indicated namespaces and scan for all annotated classes.
            Automatically create bindings.
            </summary>
            <param name="usingNamespaces">Array of namespaces. Compared using StartsWith. </param>
        </member>
        <member name="M:strange.extensions.implicitBind.impl.ImplicitBinder.ScanForAnnotatedClasses(System.String[])">
            <summary>
            Search through indicated namespaces and scan for all annotated classes.
            Automatically create bindings
            </summary>
            <param name="usingNamespaces">Array of namespaces. Compared using StartsWith. </param>
        </member>
        <member name="F:strange.extensions.injector.api.InjectionBindingScope.SINGLE_CONTEXT">
            Scope is limited to the current Context
        </member>
        <member name="F:strange.extensions.injector.api.InjectionBindingScope.CROSS_CONTEXT">
            Scope is mapped across all Contexts
        </member>
    </members>
</doc>
